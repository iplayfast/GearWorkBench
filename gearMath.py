#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Involute Gear Mathematics and Generation

This module contains all the mathematical functions for generating involute
spur gears, including the involute profile, tooth dimensions, and validation.

Copyright 2025, Chris Bruner
Version v0.1
License LGPL V2.1
Homepage https://github.com/iplayfast/GearWorkbench

References:
- Involute function: https://en.wikipedia.org/wiki/Involute
- Gear mathematics: Dudley's Handbook of Practical Gear Design
- Profile shifting: https://www.stlgears.com/theory#profile_shifting
"""

import math
import logging
from typing import Tuple, List, Dict, Any, Optional
import FreeCAD
from FreeCAD import Base
try:
    import FreeCADGui as Gui
    GUI_AVAILABLE = True
except ImportError:
    GUI_AVAILABLE = False
import FreeCAD as App
import Part
from Part import BSplineCurve, makePolygon
import Sketcher

# Import common utilities
import util
from util import DEG_TO_RAD, RAD_TO_DEG, ParameterValidationError

# Setup logging
logger = logging.getLogger(__name__)
if not logging.getLogger().handlers:
    logging.basicConfig(level=logging.INFO, format='%(levelname)s - %(message)s')

# Gear-specific constants
MIN_TEETH = 6
MAX_TEETH = 150
MIN_MODULE = 0.30  # mm
MAX_MODULE = 75.0  # mm
MIN_PRESSURE_ANGLE = 1.0  # degrees
MAX_PRESSURE_ANGLE = 35.0  # degrees
STANDARD_PRESSURE_ANGLE = 20.0  # degrees
MIN_PROFILE_SHIFT = -1.0
MAX_PROFILE_SHIFT = 1.0

# Standard gear tooth proportions (ISO 53:1998)
ADDENDUM_FACTOR = 1.0  # ha* = 1.0 module
DEDENDUM_FACTOR = 1.25  # hf* = 1.25 module
CLEARANCE_FACTOR = 0.25  # c* = 0.25 module


# Use common exception type
class GearParameterError(ParameterValidationError):
    """Raised when gear parameters are invalid."""
    pass


def involuteFunction(angle: float) -> float:
    """Calculate the involute function: inv(α) = tan(α) - α.

    The involute function is used in gear calculations to relate
    pressure angles at different radii.

    Args:
        angle: Angle in radians

    Returns:
        Involute function value in radians
    """
    return math.tan(angle) - angle


def involutePoint(base_radius: float, theta: float) -> Tuple[float, float]:
    """Calculate a point on the involute curve.

    An involute curve is generated by unwrapping a string from a circle.
    This is the fundamental profile shape of gear teeth.

    Args:
        base_radius: Radius of the base circle from which involute is generated
        theta: Roll angle in radians (how far the string has unwrapped)

    Returns:
        Tuple of (x, y) coordinates
    """
    x = base_radius * (math.cos(theta) + theta * math.sin(theta))
    y = base_radius * (math.sin(theta) - theta * math.cos(theta))
    return x, y


def calcPitchDiameter(module: float, num_teeth: int) -> float:
    """Calculate pitch diameter.

    The pitch diameter is where two gears mesh. It's the fundamental
    dimension that determines center distance between gears.

    Formula: d = m × z

    Args:
        module: Gear module in mm
        num_teeth: Number of teeth

    Returns:
        Pitch diameter in mm
    """
    return module * num_teeth


def calcBaseDiameter(pitch_diameter: float, pressure_angle_deg: float) -> float:
    """Calculate base circle diameter.

    The base circle is where the involute curve begins. All involutes
    on a gear originate from this circle.

    Formula: db = d × cos(α)

    Args:
        pitch_diameter: Pitch diameter in mm
        pressure_angle_deg: Pressure angle in degrees

    Returns:
        Base diameter in mm
    """
    pressure_angle_rad = pressure_angle_deg * DEG_TO_RAD
    return pitch_diameter * math.cos(pressure_angle_rad)


def calcAddendumDiameter(pitch_diameter: float, module: float, profile_shift: float = 0.0) -> float:
    """Calculate addendum (outer tip) diameter.

    The addendum is the radial distance from pitch circle to tooth tip.
    Profile shifting moves the cutter and changes this dimension.

    Formula: da = d + 2m(1 + x)

    Args:
        pitch_diameter: Pitch diameter in mm
        module: Gear module in mm
        profile_shift: Profile shift coefficient (dimensionless)

    Returns:
        Addendum diameter in mm
    """
    return pitch_diameter + 2 * module * (ADDENDUM_FACTOR + profile_shift)


def calcDedendumDiameter(pitch_diameter: float, module: float, profile_shift: float = 0.0) -> float:
    """Calculate dedendum (root) diameter.

    The dedendum is the radial distance from pitch circle to tooth root.

    Formula: df = d - 2m(hf* - x)

    Args:
        pitch_diameter: Pitch diameter in mm
        module: Gear module in mm
        profile_shift: Profile shift coefficient (dimensionless)

    Returns:
        Dedendum diameter in mm
    """
    return pitch_diameter - 2 * module * (DEDENDUM_FACTOR - profile_shift)


def calcBaseToothThickness(module: float, pressure_angle_deg: float, profile_shift: float = 0.0) -> float:
    """Calculate tooth thickness at the pitch circle.

    Standard tooth thickness is half the circular pitch. Profile shifting
    increases (positive x) or decreases (negative x) this thickness.

    Formula: s = m(π/2 + 2x·tan(α))

    Args:
        module: Gear module in mm
        pressure_angle_deg: Pressure angle in degrees
        profile_shift: Profile shift coefficient (dimensionless)

    Returns:
        Tooth thickness at pitch circle in mm
    """
    pressure_angle_rad = pressure_angle_deg * DEG_TO_RAD
    return module * (math.pi / 2.0 + 2.0 * profile_shift * math.tan(pressure_angle_rad))


def checkUndercut(num_teeth: int, pressure_angle_deg: float, profile_shift: float = 0.0) -> Tuple[bool, float]:
    """Check if gear will have undercutting and calculate minimum teeth.

    Undercutting occurs when too few teeth cause the cutter to remove
    part of the involute profile, weakening the tooth. Profile shifting
    can prevent undercutting.

    Formula: z_min = 2·ha* / sin²(α) - 2x

    Args:
        num_teeth: Number of teeth
        pressure_angle_deg: Pressure angle in degrees
        profile_shift: Profile shift coefficient

    Returns:
        Tuple of (has_undercut: bool, min_teeth: float)
    """
    pressure_angle_rad = pressure_angle_deg * DEG_TO_RAD
    sin_alpha = math.sin(pressure_angle_rad)

    # Minimum teeth without undercutting
    min_teeth = 2.0 * ADDENDUM_FACTOR / (sin_alpha * sin_alpha) - 2.0 * profile_shift

    has_undercut = num_teeth < min_teeth
    return has_undercut, min_teeth


def validateSpurParameters(parameters: Dict[str, Any]) -> None:
    """Validate spur gear parameters for physical and mathematical constraints.

    Args:
        parameters: Dictionary containing gear parameters

    Raises:
        GearParameterError: If any parameter is invalid
    """
    # Extract parameters
    module = parameters.get("module", 0)
    num_teeth = parameters.get("num_teeth", 0)
    pressure_angle = parameters.get("pressure_angle", 0)
    profile_shift = parameters.get("profile_shift", 0)
    height = parameters.get("height", 0)

    # Module validation
    if module < MIN_MODULE:
        raise GearParameterError(f"Module must be >= {MIN_MODULE} mm, got {module}")
    if module > MAX_MODULE:
        raise GearParameterError(f"Module must be <= {MAX_MODULE} mm, got {module}")

    # Teeth validation
    if not isinstance(num_teeth, int) or num_teeth < MIN_TEETH:
        raise GearParameterError(f"Number of teeth must be an integer >= {MIN_TEETH}, got {num_teeth}")
    if num_teeth > MAX_TEETH:
        raise GearParameterError(f"Number of teeth must be <= {MAX_TEETH}, got {num_teeth}")

    # Pressure angle validation
    if pressure_angle < MIN_PRESSURE_ANGLE:
        raise GearParameterError(f"Pressure angle must be >= {MIN_PRESSURE_ANGLE}°, got {pressure_angle}°")
    if pressure_angle > MAX_PRESSURE_ANGLE:
        raise GearParameterError(f"Pressure angle must be <= {MAX_PRESSURE_ANGLE}°, got {pressure_angle}°")

    # Profile shift validation
    if profile_shift < MIN_PROFILE_SHIFT:
        raise GearParameterError(f"Profile shift must be >= {MIN_PROFILE_SHIFT}, got {profile_shift}")
    if profile_shift > MAX_PROFILE_SHIFT:
        raise GearParameterError(f"Profile shift must be <= {MAX_PROFILE_SHIFT}, got {profile_shift}")

    # Height validation
    if height <= 0:
        raise GearParameterError(f"Height must be > 0, got {height}")

    # Check for undercutting
    has_undercut, min_teeth = checkUndercut(num_teeth, pressure_angle, profile_shift)
    if has_undercut:
        logger.warning(
            f"Gear may have undercutting! {num_teeth} teeth with {pressure_angle}° pressure angle "
            f"requires minimum {min_teeth:.1f} teeth. Consider increasing teeth or using positive "
            f"profile shift (currently {profile_shift})."
        )

    logger.info("Parameter validation passed")


def generateInvoluteProfile(base_radius: float, start_angle: float, end_angle: float,
                              num_points: int = 20) -> List[Tuple[float, float]]:
    """Generate points along an involute curve.

    Args:
        base_radius: Radius of base circle
        start_angle: Starting roll angle in radians
        end_angle: Ending roll angle in radians
        num_points: Number of points to generate

    Returns:
        List of (x, y) coordinate tuples
    """
    points = []
    for i in range(num_points):
        t = i / (num_points - 1)
        theta = start_angle + t * (end_angle - start_angle)
        x, y = involutePoint(base_radius, theta)
        points.append((x, y))
    return points


def generateDefaultParameters() -> Dict[str, Any]:
    """Generate default spur gear parameters.

    Returns:
        Dictionary of default parameters suitable for 3D printing
    """
    return {
        "module": 1.0,  # mm - metric standard
        "num_teeth": 20,  # No undercutting at 20° pressure angle
        "pressure_angle": 20.0,  # degrees - ISO standard
        "profile_shift": 0.0,  # No shift
        "height": 10.0,  # mm - reasonable thickness
        "bore_type": "none",  # No central hole
        "bore_diameter": 5.0,  # mm
    }

# --- 6. Add Scaffolding Arc (The REAL Root) ---
    # We want the arc to go from 11 o'clock to 1 o'clock THROUGH 6 o'clock.
    
    # Calculate start/end points on the Root Circle
    # Note: These angles are usually around pi/2 (top). 
    # We need to verify exactly where start/end are.
    
    # Let's calculate the vector for the Start and End of the intended arc
    # root_start_angle ~ 11 o'clock (in radians)
    # root_end_angle ~ 1 o'clock (in radians)
    
    p_start = App.Vector(
        (df/2.0) * math.cos(root_start_angle),
        (df/2.0) * math.sin(root_start_angle),
        0
    )
    p_end = App.Vector(
        (df/2.0) * math.cos(root_end_angle),
        (df/2.0) * math.sin(root_end_angle),
        0
    )
    
    # Calculate a "via" point at the bottom (6 o'clock) to force the long path
    p_bottom = App.Vector(0, -df/2.0, 0)

    # Create the arc using 3 points: Start -> Bottom -> End
    root_arc_geo = Part.Arc(p_start, p_bottom, p_end)
    arc_index = sketch.addGeometry(root_arc_geo, False) # False = Real geometry
    
    # Constrain the Arc
    # 1. Center at Origin
    sketch.addConstraint(Sketcher.Constraint('Coincident', arc_index, 3, -1, 1))
    # 2. Radius is Dedendum/2
    sketch.addConstraint(Sketcher.Constraint('Radius', arc_index, df/2.0))
    
    # 3. Scaffolding Line (connects the two top endpoints)
    line_info = util.sketchLineByPoints(sketch, p_start, p_end, isConstruction=True)
    line_index = line_info['index']
    
    # Connect Line to Arc Endpoints
    sketch.addConstraint(Sketcher.Constraint('Coincident', line_index, 1, arc_index, 1))
    sketch.addConstraint(Sketcher.Constraint('Coincident', line_index, 2, arc_index, 2))
    
    # Lock Rotation (Symmetric at top)
    sketch.addConstraint(Sketcher.Constraint('Symmetric', line_index, 1, line_index, 2, -2))

    logger.info(f"Scaffolding Arc (Long Path) added, idx={arc_index}")


def generateToothProfile(sketch, parameters: Dict[str, Any]):
    """
    Generate a single tooth profile with minimal root connection.

    Strategy: Create tooth with small root arc only (not full dedendum circle).
    The full dedendum circle will be added after polar patterning to avoid overlap.

    1. Calculate the exact flank points (involute curves).
    2. Draw them as a polygon and block them.
    3. Connect flanks with a SMALL root arc (just connecting the two sides).
    4. Add tip arc at the top.
    """
    # --- 1. Calculate Dimensions ---
    module = parameters["module"]
    num_teeth = parameters["num_teeth"]
    pressure_angle_rad = parameters["pressure_angle"] * DEG_TO_RAD
    profile_shift = parameters.get("profile_shift", 0.0)

    dw = module * num_teeth
    dg = dw * math.cos(pressure_angle_rad)
    da = dw + 2 * module * (1 + profile_shift)
    df = dw - 2 * module * (1.25 - profile_shift)

    logger.info(f"Gear Dims: dw={dw:.2f}, dg={dg:.2f}, da={da:.2f}, df={df:.2f}")

    # --- 2. Calculate Involute Points ---
    inv_alpha = math.tan(pressure_angle_rad) - pressure_angle_rad
    involute_rot = (math.sqrt(max(0, (dw**2 - dg**2))) / dg - math.atan(math.sqrt(max(0, (dw**2 - dg**2))) / dg)) + \
                   (1.0 / num_teeth) * (math.pi / 2.0 + 2.0 * profile_shift * math.tan(pressure_angle_rad))

    num_inv_points = 20

    # If Root < Base, start involute at 0.0 (Base Circle), we will add the radial drop later
    involute_start = 0.0
    if dg <= df:
        involute_start = math.sqrt(max(0, df**2 - dg**2)) / dg

    involute_end = math.sqrt(max(0, da**2 - dg**2)) / dg

    # --- 3. Generate Flank Points (Right Side) ---
    involute_pts_raw = []

    # [STEP 3a] Add Radial Drop: If Root is below Base, add a straight line from Root to Base
    if df < dg:
        involute_pts_raw.append( (df/2.0, 0.0) )

    # [STEP 3b] Generate Involute Curve
    for i in range(num_inv_points):
        t = i / (num_inv_points - 1)
        phi = involute_start + t * (involute_end - involute_start)
        x_inv = (dg / 2.0) * (math.cos(phi) + phi * math.sin(phi))
        y_inv = (dg / 2.0) * (math.sin(phi) - phi * math.cos(phi))
        involute_pts_raw.append((x_inv, y_inv))

    # --- 4. Rotate and Mirror Points ---
    # Center the tooth on +Y axis
    right_flank_rotation = math.pi / 2.0 - involute_rot

    right_flank_points = []
    for x_pt, y_pt in involute_pts_raw:
        x_rot, y_rot = util.rotatePoint(x_pt, y_pt, right_flank_rotation)
        right_flank_points.append(App.Vector(x_rot, y_rot, 0))

    left_flank_points = []
    for vec in reversed(right_flank_points):
        left_flank_points.append(App.Vector(-vec.x, vec.y, 0))

    # --- 5. Add Construction Circles (Visual Reference) ---
    util.sketchCircle(sketch, 0, 0, da, -1, "addendum", True)
    util.sketchCircle(sketch, 0, 0, dw, -1, "pitch", True)
    util.sketchCircle(sketch, 0, 0, dg, -1, "base", True)
    util.sketchCircle(sketch, 0, 0, df, -1, "dedendum", True)

    # --- 6. Add Flanks (The Frozen Statue) ---
    try:
        # Add polygons
        right_idxs = util.addPolygonToSketch(sketch, right_flank_points, closed=False)
        left_idxs = util.addPolygonToSketch(sketch, left_flank_points, closed=False)

        # [CRITICAL FIX] Block EVERY segment.
        # This creates a rigid statue of the tooth. No constraints needed, no solving needed.
        for idx in right_idxs:
            sketch.addConstraint(Sketcher.Constraint('Block', idx))
        for idx in left_idxs:
            sketch.addConstraint(Sketcher.Constraint('Block', idx))

        logger.info("Flanks added and fully Blocked (0 DOFs)")

        # --- 7. Add SMALL Root Arc (just connecting the two flanks) ---
        # This is a MINOR arc, only spanning the tooth width at the root.
        # The MAJOR arc (dedendum circle) will be added AFTER the polar pattern.

        # Get start/end points from the fixed flanks
        p_right_bottom = right_flank_points[0]
        p_left_bottom = left_flank_points[-1]

        # Calculate their angles
        angle_R = math.atan2(p_right_bottom.y, p_right_bottom.x)
        angle_L = math.atan2(p_left_bottom.y, p_left_bottom.x)

        # Draw a SMALL arc from Right to Left (standard CCW, SHORT way)
        # This only connects the two tooth flanks
        start_angle = angle_R
        end_angle = angle_L

        # Use util.sketchArc (which uses center 0,0)
        root_arc_info = util.sketchArc(sketch, 0, 0, df, start_angle, end_angle, "root_arc", isConstruction=False)
        root_idx = root_arc_info['index']

        # Connect Root Arc to Flanks
        # Start of Arc -> Start of Right Flank
        sketch.addConstraint(Sketcher.Constraint('Coincident', root_idx, 1, right_idxs[0], 1))
        # End of Arc -> End of Left Flank
        sketch.addConstraint(Sketcher.Constraint('Coincident', root_idx, 2, left_idxs[-1], 2))

        logger.info("Root Arc (Minor - tooth base only) added and connected")

        # --- 8. Add Tip Arc ---
        # Tip arc is short, so we draw Right -> Left (Standard)
        tip_start_vec = right_flank_points[-1]
        tip_end_vec = left_flank_points[0]
        tip_mid_vec = App.Vector(0, da/2.0, 0)

        tip_arc = Part.Arc(tip_start_vec, tip_mid_vec, tip_end_vec)
        tip_idx = sketch.addGeometry(tip_arc, False)

        # Constrain Tip Arc
        sketch.addConstraint(Sketcher.Constraint('Coincident', tip_idx, 1, right_idxs[-1], 2))
        sketch.addConstraint(Sketcher.Constraint('Coincident', tip_idx, 2, left_idxs[0], 1))
        sketch.addConstraint(Sketcher.Constraint('Coincident', tip_idx, 3, -1, 1))

        logger.info("Tooth profile complete and fully constrained.")

    except Exception as e:
        logger.error(f"Could not create or connect tooth profile: {e}")
        import traceback
        logger.error(traceback.format_exc())

  

def generateSpurGearPart(doc, parameters):
    """
    Generate a complete spur gear 3D model by creating a constrained sketch
    and padding it.

    Optimization: Creates tooth profile with minimal root arc, applies polar pattern,
    then adds the dedendum circle to avoid overlapping geometry during patterning.
    """
    validateSpurParameters(parameters)
    logger.info("Generating spur gear")

    body = util.readyPart(doc, 'spur_gear')

    num_teeth = parameters["num_teeth"]
    height = parameters["height"]
    bore_type = parameters.get("bore_type", "none")

    # Calculate dedendum diameter for later use
    module = parameters["module"]
    profile_shift = parameters.get("profile_shift", 0.0)
    dw = module * num_teeth
    df = dw - 2 * module * (DEDENDUM_FACTOR - profile_shift)

    # Create an empty sketch for the tooth profile
    sketch = util.createSketch(body, 'ToothProfile')

    # Populate the sketch with the tooth profile geometry and constraints
    generateToothProfile(sketch, parameters)

    # Pad the single tooth profile
    tooth_pad = util.createPad(body, sketch, height, 'Tooth')

    # Create a polar pattern of the tooth
    polar = util.createPolar(body, tooth_pad, sketch, num_teeth, 'Teeth')
    polar.Originals = [tooth_pad]
    tooth_pad.Visibility = False
    polar.Visibility = True
    body.Tip = polar

    # Now add the dedendum circle to fill the center
    # This avoids the overlapping arc problem during polar patterning
    logger.info("Adding dedendum circle to complete gear")
    dedendum_sketch = util.createSketch(body, 'DedendumCircle')
    circle = dedendum_sketch.addGeometry(Part.Circle(App.Vector(0, 0, 0), App.Vector(0, 0, 1), df / 2), False)
    dedendum_sketch.addConstraint(Sketcher.Constraint('Coincident', circle, 3, -1, 1))
    dedendum_sketch.addConstraint(Sketcher.Constraint('Diameter', circle, df))

    # Pad the dedendum circle
    dedendum_pad = util.createPad(body, dedendum_sketch, height, 'DedendumCircle')
    body.Tip = dedendum_pad

    if bore_type != "none":
        generateBore(body, parameters, height)

    doc.recompute()

    if GUI_AVAILABLE:
        try:
            Gui.SendMsgToActiveView("ViewFit")
        except Exception as e:
            logger.debug(f"Could not fit view: {e}")

    logger.info("Spur gear generation complete")


def generateBore(body, parameters, height):
    """Generate center bore in gear.

    Args:
        body: FreeCAD Body object
        parameters: Gear parameters
        height: Depth of bore
    """
    bore_type = parameters["bore_type"]
    bore_diameter = parameters["bore_diameter"]

    if bore_type == "circular":
        generateCircularBore(body, bore_diameter, height)
    elif bore_type == "square":
        corner_radius = parameters.get("square_corner_radius", 0.5)
        generateSquareBore(body, bore_diameter, corner_radius, height)
    elif bore_type == "hexagonal":
        corner_radius = parameters.get("hex_corner_radius", 0.5)
        generateHexBore(body, bore_diameter, corner_radius, height)
    elif bore_type == "keyway":
        keyway_width = parameters.get("keyway_width", 2.0)
        keyway_depth = parameters.get("keyway_depth", 1.0)
        generateKeywayBore(body, bore_diameter, keyway_width, keyway_depth, height)


def generateCircularBore(body, diameter, height):
    """Generate simple circular bore.

    Args:
        body: FreeCAD Body object
        diameter: Bore diameter
        height: Bore depth
    """
    sketch = util.createSketch(body, 'CircularBore')
    circle = sketch.addGeometry(Part.Circle(App.Vector(0, 0, 0), App.Vector(0, 0, 1), diameter / 2), False)
    sketch.addConstraint(Sketcher.Constraint('Coincident', circle, 3, -1, 1))
    sketch.addConstraint(Sketcher.Constraint('Diameter', circle, diameter))

    pocket = util.createPocket(body, sketch, height, 'Bore')
    body.Tip = pocket


def generateSquareBore(body, size, corner_radius, height):
    """Generate square bore with rounded corners.

    Args:
        body: FreeCAD Body object
        size: Square size (diameter of circumscribed circle)
        corner_radius: Radius of corners
        height: Bore depth
    """
    sketch = util.createSketch(body, 'SquareBore')
    half_size = size / (2 * math.sqrt(2))  # Half side length

    # Create square with rounded corners
    # This is simplified - a proper implementation would use fillets
    points = [
        App.Vector(half_size, half_size, 0),
        App.Vector(-half_size, half_size, 0),
        App.Vector(-half_size, -half_size, 0),
        App.Vector(half_size, -half_size, 0),
        App.Vector(half_size, half_size, 0)
    ]

    for i in range(len(points) - 1):
        sketch.addGeometry(Part.LineSegment(points[i], points[i + 1]), False)

    pocket = util.createPocket(body, sketch, height, 'Bore')
    body.Tip = pocket


def generateHexBore(body, diameter, corner_radius, height):
    """Generate hexagonal bore.

    Args:
        body: FreeCAD Body object
        diameter: Diameter of circumscribed circle
        corner_radius: Radius of corners
        height: Bore depth
    """
    sketch = util.createSketch(body, 'HexBore')
    radius = diameter / 2.0

    # Create hexagon points
    points = []
    for i in range(7):  # 7 points to close the hexagon
        angle = i * 60 * DEG_TO_RAD
        x = radius * math.cos(angle)
        y = radius * math.sin(angle)
        points.append(App.Vector(x, y, 0))

    # Add lines
    for i in range(6):
        sketch.addGeometry(Part.LineSegment(points[i], points[i + 1]), False)

    pocket = util.createPocket(body, sketch, height, 'Bore')
    body.Tip = pocket


def generateKeywayBore(body, bore_diameter, keyway_width, keyway_depth, height):
    """Generate bore with DIN 6885 keyway.

    Args:
        body: FreeCAD Body object
        bore_diameter: Diameter of circular bore
        keyway_width: Width of keyway
        keyway_depth: Depth of keyway from bore surface
        height: Total depth
    """
    # First create circular bore
    generateCircularBore(body, bore_diameter, height)

    # Add keyway as additional pocket
    sketch = util.createSketch(body, 'Keyway')

    # Keyway is a rectangle
    half_width = keyway_width / 2.0
    keyway_length = bore_diameter  # Extends across diameter

    points = [
        App.Vector(-half_width, 0, 0),
        App.Vector(half_width, 0, 0),
        App.Vector(half_width, keyway_length, 0),
        App.Vector(-half_width, keyway_length, 0),
        App.Vector(-half_width, 0, 0)
    ]

    for i in range(len(points) - 1):
        sketch.addGeometry(Part.LineSegment(points[i], points[i + 1]), False)

    pocket = util.createPocket(body, sketch, keyway_depth, 'Keyway')
    body.Tip = pocket


# ============================================================================
# Internal Gear Functions
# ============================================================================

def calcInternalAddendumDiameter(pitch_diameter: float, module: float, profile_shift: float = 0.0) -> float:
    """Calculate internal gear addendum (inner tip) diameter.

    For internal gears, the addendum points INWARD, so it's smaller than pitch diameter.

    Formula: da_internal = d - 2m(1 + x)

    Args:
        pitch_diameter: Pitch diameter in mm
        module: Gear module in mm
        profile_shift: Profile shift coefficient (dimensionless)

    Returns:
        Inner (addendum) diameter in mm
    """
    return pitch_diameter - 2 * module * (ADDENDUM_FACTOR + profile_shift)


def calcInternalDedendumDiameter(pitch_diameter: float, module: float,
                                  profile_shift: float = 0.0, rim_thickness: float = 5.0) -> float:
    """Calculate internal gear dedendum (outer) diameter.

    For internal gears, the dedendum is at the OUTER edge of the ring.
    We add rim_thickness beyond the tooth root for structural strength.

    Formula: df_internal = d + 2m(hf* - x) + 2*rim_thickness

    Args:
        pitch_diameter: Pitch diameter in mm
        module: Gear module in mm
        profile_shift: Profile shift coefficient (dimensionless)
        rim_thickness: Extra material beyond tooth root in mm

    Returns:
        Outer (dedendum) diameter in mm
    """
    return pitch_diameter + 2 * module * (DEDENDUM_FACTOR - profile_shift) + 2 * rim_thickness


def generateDefaultInternalParameters() -> Dict[str, Any]:
    """Generate default internal gear parameters.

    Returns:
        Dictionary of default parameters
    """
    return {
        "module": 1.0,  # mm - smaller for easier testing
        "num_teeth": 15,  # Fewer teeth for faster generation/testing
        "pressure_angle": 20.0,  # degrees - ISO standard
        "profile_shift": 0.0,  # No shift
        "height": 10.0,  # mm - reasonable thickness
        "rim_thickness": 3.0,  # mm - rim beyond tooth roots
    }


def validateInternalParameters(parameters: Dict[str, Any]) -> None:
    """Validate internal gear parameters.

    Args:
        parameters: Dictionary containing gear parameters

    Raises:
        GearParameterError: If any parameter is invalid
    """
    # Extract parameters
    module = parameters.get("module", 0)
    num_teeth = parameters.get("num_teeth", 0)
    pressure_angle = parameters.get("pressure_angle", 0)
    profile_shift = parameters.get("profile_shift", 0)
    height = parameters.get("height", 0)
    rim_thickness = parameters.get("rim_thickness", 0)

    # Module validation
    if module < MIN_MODULE:
        raise GearParameterError(f"Module must be >= {MIN_MODULE} mm, got {module}")
    if module > MAX_MODULE:
        raise GearParameterError(f"Module must be <= {MAX_MODULE} mm, got {module}")

    # Teeth validation
    # Internal gears can have fewer teeth than external gears without undercut issues
    min_internal_teeth = 6  # Minimum practical for internal gears
    if not isinstance(num_teeth, int) or num_teeth < min_internal_teeth:
        raise GearParameterError(f"Number of teeth must be an integer >= {min_internal_teeth}, got {num_teeth}")
    if num_teeth > MAX_TEETH:
        raise GearParameterError(f"Number of teeth must be <= {MAX_TEETH}, got {num_teeth}")

    # Pressure angle validation
    if pressure_angle < MIN_PRESSURE_ANGLE:
        raise GearParameterError(f"Pressure angle must be >= {MIN_PRESSURE_ANGLE}°, got {pressure_angle}°")
    if pressure_angle > MAX_PRESSURE_ANGLE:
        raise GearParameterError(f"Pressure angle must be <= {MAX_PRESSURE_ANGLE}°, got {pressure_angle}°")

    # Profile shift validation
    if profile_shift < MIN_PROFILE_SHIFT:
        raise GearParameterError(f"Profile shift must be >= {MIN_PROFILE_SHIFT}, got {profile_shift}")
    if profile_shift > MAX_PROFILE_SHIFT:
        raise GearParameterError(f"Profile shift must be <= {MAX_PROFILE_SHIFT}, got {profile_shift}")

    # Height validation
    if height <= 0:
        raise GearParameterError(f"Height must be > 0, got {height}")

    # Rim thickness validation
    if rim_thickness < 0.5:
        raise GearParameterError(f"Rim thickness must be >= 0.5 mm, got {rim_thickness}")

    logger.info("Internal gear parameter validation passed")


def generateInternalToothProfile(sketch, parameters: Dict[str, Any]):
    """
    Generate a single internal tooth SOLID profile (not a cavity).

    The tooth points INWARD toward the center. After padding and polar patterning,
    we'll add a ring that fills the gaps around the teeth.
    """
    print("=" * 60)
    print("INTERNAL TOOTH PROFILE GENERATION (SOLID TOOTH)")
    print("=" * 60)

    # Calculate dimensions
    module = parameters["module"]
    num_teeth = parameters["num_teeth"]
    pressure_angle_rad = parameters["pressure_angle"] * DEG_TO_RAD
    profile_shift = parameters.get("profile_shift", 0.0)

    dw = module * num_teeth
    dg = dw * math.cos(pressure_angle_rad)
    da_internal = dw - 2 * module * (ADDENDUM_FACTOR + profile_shift)
    df_internal = dw + 2 * module * (DEDENDUM_FACTOR - profile_shift)

    print(f"Module: {module}, Teeth: {num_teeth}")
    print(f"Pitch diameter (dw): {dw:.3f}")
    print(f"Base diameter (dg): {dg:.3f}")
    print(f"Inner diameter (da): {da_internal:.3f}")
    print(f"Outer diameter (df): {df_internal:.3f}")

    # Calculate tooth angle
    involute_rot = (math.sqrt(max(0, (dw**2 - dg**2))) / dg - math.atan(math.sqrt(max(0, (dw**2 - dg**2))) / dg)) + \
                   (1.0 / num_teeth) * (math.pi / 2.0 + 2.0 * profile_shift * math.tan(pressure_angle_rad))

    print(f"Involute rotation: {involute_rot * RAD_TO_DEG:.3f} degrees")

    # Generate involute points
    num_inv_points = 10
    involute_start = math.sqrt(max(0, da_internal**2 - dg**2)) / dg if da_internal > dg else 0.0
    involute_end = math.sqrt(max(0, df_internal**2 - dg**2)) / dg

    print(f"Involute range: {involute_start:.3f} to {involute_end:.3f}")

    involute_pts_raw = []
    for i in range(num_inv_points):
        t = i / (num_inv_points - 1)
        phi = involute_start + t * (involute_end - involute_start)
        x_inv = (dg / 2.0) * (math.cos(phi) + phi * math.sin(phi))
        y_inv = (dg / 2.0) * (math.sin(phi) - phi * math.cos(phi))
        involute_pts_raw.append((x_inv, y_inv))

    # Rotate points for RIGHT flank
    # Position tooth at 12 o'clock (top, +Y axis)
    right_flank_rotation = math.pi / 2.0 + involute_rot
    print(f"Right flank rotation: {right_flank_rotation * RAD_TO_DEG:.3f} degrees")

    right_flank_points = []
    for i, (x_pt, y_pt) in enumerate(involute_pts_raw):
        # Just rotate to position at top
        x_rot, y_rot = util.rotatePoint(x_pt, y_pt, right_flank_rotation)
        right_flank_points.append(App.Vector(x_rot, y_rot, 0))
        if i == 0:
            print(f"First point (inner): ({x_rot:.3f}, {y_rot:.3f})")
        elif i == len(involute_pts_raw) - 1:
            print(f"Last point (outer): ({x_rot:.3f}, {y_rot:.3f})")

    # Mirror for left
    left_flank_points = []
    for vec in reversed(right_flank_points):
        left_flank_points.append(App.Vector(-vec.x, vec.y, 0))

    print(f"Generated {len(right_flank_points)} points per flank")

    # Build SOLID TOOTH pointing INWARD
    # Order: Start from outer base (df) → right flank → inner tip (da) → left flank → back to outer base
    all_points = []

    # Start at outer base (right side of tooth base)
    p_right_outer = right_flank_points[-1]
    all_points.append(p_right_outer)
    print(f"Starting at outer base (right): ({p_right_outer.x:.3f}, {p_right_outer.y:.3f})")

    # Right flank (outer to inner, reversed)
    for vec in reversed(right_flank_points[:-1]):  # Exclude last point (already added)
        all_points.append(vec)
    print(f"Added right flank: {len(right_flank_points)-1} points")

    # Inner tip arc (small arc at tooth tip)
    p_right_inner = right_flank_points[0]
    p_left_inner = left_flank_points[-1]
    angle_R_inner = math.atan2(p_right_inner.y, p_right_inner.x)
    angle_L_inner = math.atan2(p_left_inner.y, p_left_inner.x)

    # Calculate angle difference - always take the SHORT way around
    angle_diff_inner = angle_L_inner - angle_R_inner
    # Normalize to [-pi, pi] range to get shortest path
    while angle_diff_inner > math.pi:
        angle_diff_inner -= 2 * math.pi
    while angle_diff_inner < -math.pi:
        angle_diff_inner += 2 * math.pi

    print(f"Inner tip arc: {angle_R_inner * RAD_TO_DEG:.3f}° to {angle_L_inner * RAD_TO_DEG:.3f}° (diff: {angle_diff_inner * RAD_TO_DEG:.3f}°)")

    for i in range(1, 4):  # 3 intermediate points (skip endpoints)
        t = i / 4
        angle = angle_R_inner + t * angle_diff_inner
        x = (da_internal / 2) * math.cos(angle)
        y = (da_internal / 2) * math.sin(angle)
        all_points.append(App.Vector(x, y, 0))
    print(f"Added inner tip arc: 3 points")

    # Left flank (inner to outer) - need to reverse since left_flank_points is outer→inner
    for vec in reversed(left_flank_points[1:]):  # Reverse and exclude first point
        all_points.append(vec)
    print(f"Added left flank: {len(left_flank_points)-1} points")

    # Outer base arc (connects left base back to right base)
    p_left_outer = left_flank_points[0]
    angle_L = math.atan2(p_left_outer.y, p_left_outer.x)
    angle_R = math.atan2(p_right_outer.y, p_right_outer.x)

    # Calculate angle difference
    angle_diff = angle_R - angle_L
    while angle_diff > math.pi:
        angle_diff -= 2 * math.pi
    while angle_diff < -math.pi:
        angle_diff += 2 * math.pi

    print(f"Outer base arc: {angle_L * RAD_TO_DEG:.3f}° to {angle_R * RAD_TO_DEG:.3f}° (diff: {angle_diff * RAD_TO_DEG:.3f}°)")

    for i in range(1, 4):  # 3 intermediate points
        t = i / 4
        angle = angle_L + t * angle_diff
        x = (df_internal / 2) * math.cos(angle)
        y = (df_internal / 2) * math.sin(angle)
        all_points.append(App.Vector(x, y, 0))
    print(f"Added outer base arc: 3 points")

    print(f"Total points in solid tooth: {len(all_points)}")
    print("=" * 60)

    # COMMENTED OUT - Testing arc-based approach instead
    # util.addPolygonToSketch(sketch, all_points, closed=True)

    # ========== NEW ARC-BASED APPROACH ==========
    print("\nTesting arc-based tooth profile using actual involute points:")

    # Use the involute points we already calculated
    # right_flank_points: goes from inner (small radius) to outer (large radius)
    # left_flank_points: same but mirrored

    print(f"Right flank has {len(right_flank_points)} points")
    print(f"Left flank has {len(left_flank_points)} points")

    # Create all arcs without connecting them yet
    arc_count = 0
    all_geo_indices = []  # Track all geometry indices

    # Right flank arcs (DO NOT CHANGE - these are perfect!)
    right_arc_indices = []  # Track arc indices for mirroring
    for i in range(0, len(right_flank_points) - 2, 2):  # Step by 2
        p1 = right_flank_points[i]
        p2 = right_flank_points[i + 1]
        p3 = right_flank_points[i + 2]
        try:
            arc = Part.Arc(p1, p2, p3)
            idx = sketch.addGeometry(arc, False)
            all_geo_indices.append(idx)
            right_arc_indices.append(idx)  # Store index for mirroring
            arc_count += 1
            print(f"✓ Right flank arc #{arc_count}: ({p1.x:.2f},{p1.y:.2f}) → ({p2.x:.2f},{p2.y:.2f}) → ({p3.x:.2f},{p3.y:.2f})")
        except Exception as e:
            print(f"✗ Right flank arc #{i} failed: {e}")

    # Left flank arcs - X-axis mirror of right flank arcs
    # Create a geometrically exact mirror by mirroring all points on the arc
    for arc_idx in right_arc_indices:
        # Get the actual arc geometry that was created
        arc_geom = sketch.Geometry[arc_idx]

        # Mirror the start and end points
        start_mirror = App.Vector(-arc_geom.StartPoint.x, arc_geom.StartPoint.y, 0)
        end_mirror = App.Vector(-arc_geom.EndPoint.x, arc_geom.EndPoint.y, 0)

        # Get middle point on the arc (not center!)
        mid_param = (arc_geom.FirstParameter + arc_geom.LastParameter) / 2
        mid_point = arc_geom.value(mid_param)
        mid_mirror = App.Vector(-mid_point.x, mid_point.y, 0)

        try:
            # SWAP start and end to reverse the arc direction for proper mirroring
            # This makes the arc bend the same way as the original
            arc_mirrored = Part.Arc(end_mirror, mid_mirror, start_mirror)

            idx = sketch.addGeometry(arc_mirrored, False)
            all_geo_indices.append(idx)
            arc_count += 1
            print(f"✓ Left flank arc #{arc_count}: ({end_mirror.x:.2f},{end_mirror.y:.2f}) → ({mid_mirror.x:.2f},{mid_mirror.y:.2f}) → ({start_mirror.x:.2f},{start_mirror.y:.2f})")
        except Exception as e:
            print(f"✗ Left flank arc mirroring failed: {e}")

    # Inner radius arc - connects left flank end (arc #4 end) to right flank start (arc #0 start)
    # Use the ACTUAL geometry endpoints
    first_right_arc = sketch.Geometry[right_arc_indices[0]]
    p_right_inner = first_right_arc.StartPoint
    p_left_inner = App.Vector(-p_right_inner.x, p_right_inner.y, 0)  # Mirror

    # Calculate the radius
    inner_radius = math.sqrt(p_right_inner.x**2 + p_right_inner.y**2)
    p_mid_inner = App.Vector(0, inner_radius, 0)

    print(f"Inner arc radius: {inner_radius:.3f}")

    try:
        # Arc should go from LEFT to RIGHT to close the loop
        # Left flank ends at p_left_inner, needs to connect to right flank start at p_right_inner
        arc_inner = Part.Arc(p_left_inner, p_mid_inner, p_right_inner)
        idx = sketch.addGeometry(arc_inner, False)
        all_geo_indices.append(idx)
        print(f"✓ Inner radius arc: ({p_left_inner.x:.2f},{p_left_inner.y:.2f}) → ({p_mid_inner.x:.2f},{p_mid_inner.y:.2f}) → ({p_right_inner.x:.2f},{p_right_inner.y:.2f})")
    except Exception as e:
        print(f"✗ Inner radius arc failed: {e}")

    # Outer radius arc - connects arc #4 end to arc #8 end
    # Use the ACTUAL geometry endpoints
    last_right_arc = sketch.Geometry[right_arc_indices[-1]]
    p_right_outer = last_right_arc.EndPoint
    p_left_outer = App.Vector(-p_right_outer.x, p_right_outer.y, 0)  # Mirror

    # Calculate the radius
    outer_radius = math.sqrt(p_right_outer.x**2 + p_right_outer.y**2)
    p_mid_outer = App.Vector(0, outer_radius, 0)

    print(f"Outer arc radius: {outer_radius:.3f}")

    try:
        arc_outer = Part.Arc(p_right_outer, p_mid_outer, p_left_outer)
        idx = sketch.addGeometry(arc_outer, False)
        all_geo_indices.append(idx)
        print(f"✓ Outer radius arc: ({p_right_outer.x:.2f},{p_right_outer.y:.2f}) → ({p_mid_outer.x:.2f},{p_mid_outer.y:.2f}) → ({p_left_outer.x:.2f},{p_left_outer.y:.2f})")
    except Exception as e:
        print(f"✗ Outer radius arc failed: {e}")

    # Now connect all the arcs using the smart connection algorithm
    print(f"\nConnecting {len(all_geo_indices)} arcs using smart endpoint matching...")

    # Debug: print all arc endpoints before connecting
    print("\nArc endpoints:")
    for i, geo_idx in enumerate(all_geo_indices):
        geom = sketch.Geometry[geo_idx]
        if hasattr(geom, 'StartPoint') and hasattr(geom, 'EndPoint'):
            print(f"  Arc {i} (geo {geo_idx}): start=({geom.StartPoint.x:.2f},{geom.StartPoint.y:.2f}) end=({geom.EndPoint.x:.2f},{geom.EndPoint.y:.2f})")

    connecting_lines = util.connectGeometryChain(sketch, all_geo_indices)
    print(f"✓ Added {len(connecting_lines)} connecting lines/constraints")

    print("=" * 60)


def generateInternalGearPart(doc, parameters):
    """
    Generate a complete internal gear 3D model.

    Optimization: EXACT same strategy as spur gear to avoid overlapping geometry.
    1. Create single tooth cavity profile (with small arcs only)
    2. Pad the tooth cavity as a solid feature
    3. Polar pattern the tooth cavities
    4. Add outer ring with inner hole to complete the gear

    The tooth cavities are created as SOLID pads, then the final ring is added
    which results in a union operation creating the final internal gear.
    """
    validateInternalParameters(parameters)
    logger.info("Generating internal gear")

    body = util.readyPart(doc, 'internal_gear')

    num_teeth = parameters["num_teeth"]
    height = parameters["height"]
    module = parameters["module"]
    profile_shift = parameters.get("profile_shift", 0.0)
    rim_thickness = parameters.get("rim_thickness", 3.0)

    # Calculate diameters
    dw = module * num_teeth
    da_internal = dw - 2 * module * (ADDENDUM_FACTOR + profile_shift)  # Inner diameter (tooth tips)
    df_internal = dw + 2 * module * (DEDENDUM_FACTOR - profile_shift)  # Tooth root diameter
    outer_diameter = df_internal + 2 * rim_thickness  # Outer ring diameter

    # --- 1. Create Tooth Profile ---
    logger.info("Creating tooth sketch")
    tooth_sketch = util.createSketch(body, 'Tooth')
    generateInternalToothProfile(tooth_sketch, parameters)

    # --- 2. Pad the single tooth as a solid ---
    tooth_pad = util.createPad(body, tooth_sketch, height, 'Tooth')
    body.Tip = tooth_pad

    # TEMPORARY: Return early to test single tooth profile without polar pattern
    logger.info("Returning early - skipping polar pattern for single tooth testing")
    return

    # --- 3. Polar Pattern the Teeth ---
    logger.info("Creating polar pattern of teeth")
    polar = util.createPolar(body, tooth_pad, tooth_sketch, num_teeth, 'Teeth')
    polar.Originals = [tooth_pad]
    tooth_pad.Visibility = False
    polar.Visibility = True
    body.Tip = polar

    # --- 4. Add Outer Ring (fills space between teeth) ---
    # Ring outer edge extends beyond tooth bases for structural strength
    # Inner edge is at df_internal to match tooth bases
    logger.info("Adding outer ring to fill gaps between teeth")
    ring_sketch = util.createSketch(body, 'Ring')

    # Outer circle (includes rim thickness for strength)
    outer_circle = ring_sketch.addGeometry(Part.Circle(App.Vector(0, 0, 0), App.Vector(0, 0, 1), outer_diameter / 2), False)
    ring_sketch.addConstraint(Sketcher.Constraint('Coincident', outer_circle, 3, -1, 1))
    ring_sketch.addConstraint(Sketcher.Constraint('Diameter', outer_circle, outer_diameter))

    # Inner hole (at tooth base diameter so it merges with tooth bases)
    inner_hole = ring_sketch.addGeometry(Part.Circle(App.Vector(0, 0, 0), App.Vector(0, 0, 1), df_internal / 2), False)
    ring_sketch.addConstraint(Sketcher.Constraint('Coincident', inner_hole, 3, -1, 1))
    ring_sketch.addConstraint(Sketcher.Constraint('Diameter', inner_hole, df_internal))

    ring_pad = util.createPad(body, ring_sketch, height, 'Ring')
    body.Tip = ring_pad

    doc.recompute()

    if GUI_AVAILABLE:
        try:
            Gui.SendMsgToActiveView("ViewFit")
        except Exception as e:
            logger.debug(f"Could not fit view: {e}")

    logger.info("Internal gear generation complete")


logger.info("gearMath module loaded successfully")
