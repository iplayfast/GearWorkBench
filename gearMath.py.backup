#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Involute Gear Mathematics and Generation

This module contains all the mathematical functions for generating involute
spur gears, including the involute profile, tooth dimensions, and validation.

Copyright 2025, Chris Bruner
Version v0.1
License LGPL V2.1
Homepage https://github.com/iplayfast/GearWorkbench

References:
- Involute function: https://en.wikipedia.org/wiki/Involute
- Gear mathematics: Dudley's Handbook of Practical Gear Design
- Profile shifting: https://www.stlgears.com/theory#profile_shifting
"""

import math
import logging
from typing import Tuple, List, Dict, Any, Optional
import FreeCAD
from FreeCAD import Base
try:
    import FreeCADGui as Gui
    GUI_AVAILABLE = True
except ImportError:
    GUI_AVAILABLE = False
import FreeCAD as App
import Part
from Part import BSplineCurve, makePolygon
import Sketcher

# Import common utilities
import util
from util import DEG_TO_RAD, RAD_TO_DEG, ParameterValidationError

# Setup logging
logger = logging.getLogger(__name__)
if not logging.getLogger().handlers:
    logging.basicConfig(level=logging.WARNING, format='%(levelname)s - %(message)s')

# Gear-specific constants
MIN_TEETH = 6
MAX_TEETH = 150
MIN_MODULE = 0.30  # mm
MAX_MODULE = 75.0  # mm
MIN_PRESSURE_ANGLE = 1.0  # degrees
MAX_PRESSURE_ANGLE = 35.0  # degrees
STANDARD_PRESSURE_ANGLE = 20.0  # degrees
MIN_PROFILE_SHIFT = -1.0
MAX_PROFILE_SHIFT = 1.0

# Standard gear tooth proportions (ISO 53:1998)
ADDENDUM_FACTOR = 1.0  # ha* = 1.0 module
DEDENDUM_FACTOR = 1.25  # hf* = 1.25 module
CLEARANCE_FACTOR = 0.25  # c* = 0.25 module


# Use common exception type
class GearParameterError(ParameterValidationError):
    """Raised when gear parameters are invalid."""
    pass


def involute_function(angle: float) -> float:
    """Calculate the involute function: inv(α) = tan(α) - α.

    The involute function is used in gear calculations to relate
    pressure angles at different radii.

    Args:
        angle: Angle in radians

    Returns:
        Involute function value in radians
    """
    return math.tan(angle) - angle


def involute_point(base_radius: float, theta: float) -> Tuple[float, float]:
    """Calculate a point on the involute curve.

    An involute curve is generated by unwrapping a string from a circle.
    This is the fundamental profile shape of gear teeth.

    Args:
        base_radius: Radius of the base circle from which involute is generated
        theta: Roll angle in radians (how far the string has unwrapped)

    Returns:
        Tuple of (x, y) coordinates
    """
    x = base_radius * (math.cos(theta) + theta * math.sin(theta))
    y = base_radius * (math.sin(theta) - theta * math.cos(theta))
    return x, y


def calc_pitch_diameter(module: float, num_teeth: int) -> float:
    """Calculate pitch diameter.

    The pitch diameter is where two gears mesh. It's the fundamental
    dimension that determines center distance between gears.

    Formula: d = m × z

    Args:
        module: Gear module in mm
        num_teeth: Number of teeth

    Returns:
        Pitch diameter in mm
    """
    return module * num_teeth


def calc_base_diameter(pitch_diameter: float, pressure_angle_deg: float) -> float:
    """Calculate base circle diameter.

    The base circle is where the involute curve begins. All involutes
    on a gear originate from this circle.

    Formula: db = d × cos(α)

    Args:
        pitch_diameter: Pitch diameter in mm
        pressure_angle_deg: Pressure angle in degrees

    Returns:
        Base diameter in mm
    """
    pressure_angle_rad = pressure_angle_deg * DEG_TO_RAD
    return pitch_diameter * math.cos(pressure_angle_rad)


def calc_addendum_diameter(pitch_diameter: float, module: float, profile_shift: float = 0.0) -> float:
    """Calculate addendum (outer tip) diameter.

    The addendum is the radial distance from pitch circle to tooth tip.
    Profile shifting moves the cutter and changes this dimension.

    Formula: da = d + 2m(1 + x)

    Args:
        pitch_diameter: Pitch diameter in mm
        module: Gear module in mm
        profile_shift: Profile shift coefficient (dimensionless)

    Returns:
        Addendum diameter in mm
    """
    return pitch_diameter + 2 * module * (ADDENDUM_FACTOR + profile_shift)


def calc_dedendum_diameter(pitch_diameter: float, module: float, profile_shift: float = 0.0) -> float:
    """Calculate dedendum (root) diameter.

    The dedendum is the radial distance from pitch circle to tooth root.

    Formula: df = d - 2m(hf* - x)

    Args:
        pitch_diameter: Pitch diameter in mm
        module: Gear module in mm
        profile_shift: Profile shift coefficient (dimensionless)

    Returns:
        Dedendum diameter in mm
    """
    return pitch_diameter - 2 * module * (DEDENDUM_FACTOR - profile_shift)


def calc_base_tooth_thickness(module: float, pressure_angle_deg: float, profile_shift: float = 0.0) -> float:
    """Calculate tooth thickness at the pitch circle.

    Standard tooth thickness is half the circular pitch. Profile shifting
    increases (positive x) or decreases (negative x) this thickness.

    Formula: s = m(π/2 + 2x·tan(α))

    Args:
        module: Gear module in mm
        pressure_angle_deg: Pressure angle in degrees
        profile_shift: Profile shift coefficient (dimensionless)

    Returns:
        Tooth thickness at pitch circle in mm
    """
    pressure_angle_rad = pressure_angle_deg * DEG_TO_RAD
    return module * (math.pi / 2.0 + 2.0 * profile_shift * math.tan(pressure_angle_rad))


def check_undercut(num_teeth: int, pressure_angle_deg: float, profile_shift: float = 0.0) -> Tuple[bool, float]:
    """Check if gear will have undercutting and calculate minimum teeth.

    Undercutting occurs when too few teeth cause the cutter to remove
    part of the involute profile, weakening the tooth. Profile shifting
    can prevent undercutting.

    Formula: z_min = 2·ha* / sin²(α) - 2x

    Args:
        num_teeth: Number of teeth
        pressure_angle_deg: Pressure angle in degrees
        profile_shift: Profile shift coefficient

    Returns:
        Tuple of (has_undercut: bool, min_teeth: float)
    """
    pressure_angle_rad = pressure_angle_deg * DEG_TO_RAD
    sin_alpha = math.sin(pressure_angle_rad)

    # Minimum teeth without undercutting
    min_teeth = 2.0 * ADDENDUM_FACTOR / (sin_alpha * sin_alpha) - 2.0 * profile_shift

    has_undercut = num_teeth < min_teeth
    return has_undercut, min_teeth


def validate_spur_parameters(parameters: Dict[str, Any]) -> None:
    """Validate spur gear parameters for physical and mathematical constraints.

    Args:
        parameters: Dictionary containing gear parameters

    Raises:
        GearParameterError: If any parameter is invalid
    """
    # Extract parameters
    module = parameters.get("module", 0)
    num_teeth = parameters.get("num_teeth", 0)
    pressure_angle = parameters.get("pressure_angle", 0)
    profile_shift = parameters.get("profile_shift", 0)
    height = parameters.get("height", 0)

    # Module validation
    if module < MIN_MODULE:
        raise GearParameterError(f"Module must be >= {MIN_MODULE} mm, got {module}")
    if module > MAX_MODULE:
        raise GearParameterError(f"Module must be <= {MAX_MODULE} mm, got {module}")

    # Teeth validation
    if not isinstance(num_teeth, int) or num_teeth < MIN_TEETH:
        raise GearParameterError(f"Number of teeth must be an integer >= {MIN_TEETH}, got {num_teeth}")
    if num_teeth > MAX_TEETH:
        raise GearParameterError(f"Number of teeth must be <= {MAX_TEETH}, got {num_teeth}")

    # Pressure angle validation
    if pressure_angle < MIN_PRESSURE_ANGLE:
        raise GearParameterError(f"Pressure angle must be >= {MIN_PRESSURE_ANGLE}°, got {pressure_angle}°")
    if pressure_angle > MAX_PRESSURE_ANGLE:
        raise GearParameterError(f"Pressure angle must be <= {MAX_PRESSURE_ANGLE}°, got {pressure_angle}°")

    # Profile shift validation
    if profile_shift < MIN_PROFILE_SHIFT:
        raise GearParameterError(f"Profile shift must be >= {MIN_PROFILE_SHIFT}, got {profile_shift}")
    if profile_shift > MAX_PROFILE_SHIFT:
        raise GearParameterError(f"Profile shift must be <= {MAX_PROFILE_SHIFT}, got {profile_shift}")

    # Height validation
    if height <= 0:
        raise GearParameterError(f"Height must be > 0, got {height}")

    # Check for undercutting
    has_undercut, min_teeth = check_undercut(num_teeth, pressure_angle, profile_shift)
    if has_undercut:
        logger.warning(
            f"Gear may have undercutting! {num_teeth} teeth with {pressure_angle}° pressure angle "
            f"requires minimum {min_teeth:.1f} teeth. Consider increasing teeth or using positive "
            f"profile shift (currently {profile_shift})."
        )

    logger.info("Parameter validation passed")


def generate_involute_profile(base_radius: float, start_angle: float, end_angle: float,
                              num_points: int = 20) -> List[Tuple[float, float]]:
    """Generate points along an involute curve.

    Args:
        base_radius: Radius of base circle
        start_angle: Starting roll angle in radians
        end_angle: Ending roll angle in radians
        num_points: Number of points to generate

    Returns:
        List of (x, y) coordinate tuples
    """
    points = []
    for i in range(num_points):
        t = i / (num_points - 1)
        theta = start_angle + t * (end_angle - start_angle)
        x, y = involute_point(base_radius, theta)
        points.append((x, y))
    return points


def generate_default_parameters() -> Dict[str, Any]:
    """Generate default spur gear parameters.

    Returns:
        Dictionary of default parameters suitable for 3D printing
    """
    return {
        "module": 2.0,  # mm - good size for printing
        "num_teeth": 20,  # No undercutting at 20° pressure angle
        "pressure_angle": 20.0,  # degrees - ISO standard
        "profile_shift": 0.0,  # No shift
        "height": 10.0,  # mm - reasonable thickness
        "bore_type": "none",  # No central hole
        "bore_diameter": 5.0,  # mm
    }


def fcvec(x: List[float]) -> App.Vector:
    """Convert list to FreeCAD Vector.

    Args:
        x: List of 2 or 3 coordinates

    Returns:
        FreeCAD Vector object
    """
    if len(x) == 2:
        return App.Vector(x[0], x[1], 0)
    else:
        return App.Vector(x[0], x[1], x[2])


# Sketching helper functions (similar to cycloidFun.py)
def newSketch(body, name=''):
    """Create a new sketch attached to body.

    Args:
        body: FreeCAD Body object
        name: Name for the sketch

    Returns:
        Sketch object
    """
    name = name + 'Sketch'
    sketch = body.Document.addObject('Sketcher::SketchObject', name)
    body.addObject(sketch)
    sketch.Visibility = False
    return sketch


def newPad(body, sketch, height, name=''):
    """Create a pad (extrusion) from sketch.

    Args:
        body: FreeCAD Body object
        sketch: Sketch to extrude
        height: Extrusion height
        name: Name for the pad

    Returns:
        Pad object
    """
    name = name + 'Pad'
    pad = body.Document.addObject("PartDesign::Pad", name)
    body.addObject(pad)
    pad.Length = height
    pad.Profile = sketch
    return pad


def newPocket(body, sketch, height, name=''):
    """Create a pocket (cut) from sketch.

    Args:
        body: FreeCAD Body object
        sketch: Sketch to cut
        height: Cut depth
        name: Name for the pocket

    Returns:
        Pocket object
    """
    name = name + 'Pocket'
    pocket = body.Document.addObject("PartDesign::Pocket", name)
    body.addObject(pocket)
    pocket.Length = height
    pocket.Profile = sketch
    pocket.Reversed = True
    return pocket


def newPolar(body, feature, sketch, count, name=''):
    """Create polar pattern of feature.

    Args:
        body: FreeCAD Body object
        feature: Feature to pattern
        sketch: Reference sketch
        count: Number of occurrences
        name: Name for pattern

    Returns:
        Polar pattern object
    """
    name = name + 'Polar'
    polar = body.newObject('PartDesign::PolarPattern', name)
    polar.Axis = (sketch, ['N_Axis'])
    polar.Angle = 360
    polar.Occurrences = count
    return polar


def generate_tooth_profile(parameters: Dict[str, Any]) -> List[App.Vector]:
    """Generate complete tooth profile with involute curves.

    Creates one tooth AND one tooth gap for proper closed profile.
    Uses correct involute mathematics based on standard gear theory.

    Args:
        parameters: Gear parameters dictionary

    Returns:
        List of FreeCAD Vectors defining one tooth + gap (closed)
    """
    module = parameters["module"]
    num_teeth = parameters["num_teeth"]
    pressure_angle_deg = parameters["pressure_angle"]
    profile_shift = parameters["profile_shift"]

    # Calculate key diameters
    pitch_dia = calc_pitch_diameter(module, num_teeth)
    base_dia = calc_base_diameter(pitch_dia, pressure_angle_deg)
    addendum_dia = calc_addendum_diameter(pitch_dia, module, profile_shift)
    dedendum_dia = calc_dedendum_diameter(pitch_dia, module, profile_shift)

    base_radius = base_dia / 2.0
    addendum_radius = addendum_dia / 2.0
    dedendum_radius = dedendum_dia / 2.0
    pitch_radius = pitch_dia / 2.0

    pressure_angle_rad = pressure_angle_deg * DEG_TO_RAD

    # Angular spacing between teeth
    angular_pitch = 2.0 * math.pi / num_teeth

    # Tooth thickness at pitch circle (arc length)
    # Standard is pi*m / 2, adjusted for profile shift
    tooth_thickness_arc = math.pi * module / 2.0 + 2.0 * profile_shift * module * math.tan(pressure_angle_rad)
    half_tooth_angle = tooth_thickness_arc / (2.0 * pitch_radius)

    # Involute function at pressure angle
    inv_alpha = involute_function(pressure_angle_rad)

    profile = []
    num_involute_points = 20

    # For involute: point at radius r has unwrap angle theta where r = rb*sqrt(1 + theta^2)
    # Or: theta = sqrt((r/rb)^2 - 1)

    # Roll angle where involute reaches addendum
    if addendum_radius > base_radius:
        theta_addendum = math.sqrt((addendum_radius / base_radius) ** 2 - 1)
    else:
        theta_addendum = 0

    # Roll angle where involute reaches dedendum
    if dedendum_radius > base_radius:
        theta_dedendum = math.sqrt((dedendum_radius / base_radius) ** 2 - 1)
    else:
        theta_dedendum = 0

    # Calculate the angle where involute meets pitch circle
    theta_pitch = math.sqrt((pitch_radius / base_radius) ** 2 - 1)

    # The involute angle at pitch circle relative to its starting point
    # At pitch circle, the pressure angle is alpha
    # The involute angle there is inv(alpha) = tan(alpha) - alpha

    # We want half the tooth thickness at pitch circle to be half_tooth_angle
    # The involute curve angle at radius r is: theta (unwrap) - but we need to position it
    # At pitch circle: the tooth centerline is at angle 0
    # At pitch circle radius, the involute has unwrapped by theta_pitch
    # The geometric angle of that point is: theta_pitch (from involute formula)

    # To center the tooth at angle 0, we need to shift the involute
    # The shift angle at pitch circle is: half_tooth_angle - (theta_pitch - inv_alpha)

    # Actually, let's use a simpler, more direct approach:
    # Generate right flank of tooth (involute curve)
    # The involute naturally starts tangent to base circle
    # We need to rotate it so that at the pitch circle, it's at half_tooth_angle

    # Right flank angle offset
    # At pitch radius, the involute point has angle theta_pitch (the unwrap parameter)
    # and its geometric angle in polar coords is also theta_pitch
    # We want the point at pitch_radius to be at angle = half_tooth_angle
    # So rotation needed = half_tooth_angle - theta_pitch

    # BUT the involute function tells us the angle is actually:
    # geometric_angle = theta - inv(angle_at_that_point)
    # This is getting too complex. Let me use the standard formula.

    # Standard approach: generate involute in standard position, then rotate
    # For a gear tooth centered at angle 0:
    # - Right flank: involute rotated to +half_tooth_angle at pitch circle
    # - Left flank: mirror of right flank

    # The angle of rotation needed: at pitch circle, the profile point should be at half_tooth_angle
    # The involute at pitch circle (theta = theta_pitch) has geometric angle = theta_pitch
    # We need to add: half_tooth_angle - theta_pitch + inv_alpha

    angle_offset_right = half_tooth_angle - theta_pitch + inv_alpha
    angle_offset_left = -half_tooth_angle + theta_pitch - inv_alpha

    # Generate RIGHT flank (involute from dedendum/base to addendum)
    if dedendum_radius > base_radius:
        # Start at dedendum
        theta_start = theta_dedendum
    else:
        # Start at base circle
        theta_start = 0
        # Add a point at dedendum radius (straight radial line from base to dedendum)
        x = dedendum_radius * math.cos(angle_offset_right)
        y = dedendum_radius * math.sin(angle_offset_right)
        profile.append(App.Vector(x, y, 0))

    # Generate involute curve from start to addendum
    for i in range(num_involute_points + 1):
        t = i / num_involute_points
        theta = theta_start + t * (theta_addendum - theta_start)

        # Generate involute point (in natural coordinates)
        x_inv, y_inv = involute_point(base_radius, theta)

        # The geometric angle of this involute point is theta (the unwrap angle)
        # Rotate by angle_offset_right
        r = math.sqrt(x_inv**2 + y_inv**2)
        natural_angle = math.atan2(y_inv, x_inv)
        final_angle = natural_angle + angle_offset_right

        x = r * math.cos(final_angle)
        y = r * math.sin(final_angle)
        profile.append(App.Vector(x, y, 0))

    # Add tip arc
    tip_arc_points = 5
    for i in range(tip_arc_points):
        t = i / (tip_arc_points - 1.0)
        # From right flank angle to left flank angle at addendum
        angle_right = angle_offset_right + theta_addendum
        angle_left = angle_offset_left - theta_addendum
        angle = angle_right + t * (angle_left - angle_right)

        x = addendum_radius * math.cos(angle)
        y = addendum_radius * math.sin(angle)
        profile.append(App.Vector(x, y, 0))

    # Generate LEFT flank (involute from addendum to dedendum/base)
    for i in range(num_involute_points + 1):
        t = i / num_involute_points
        theta = theta_addendum - t * (theta_addendum - theta_start)

        # Generate involute point
        x_inv, y_inv = involute_point(base_radius, theta)

        r = math.sqrt(x_inv**2 + y_inv**2)
        natural_angle = math.atan2(y_inv, x_inv)
        final_angle = natural_angle + angle_offset_left

        x = r * math.cos(final_angle)
        y = r * math.sin(final_angle)
        profile.append(App.Vector(x, y, 0))

    if dedendum_radius <= base_radius:
        # Add point at dedendum radius
        x = dedendum_radius * math.cos(angle_offset_left)
        y = dedendum_radius * math.sin(angle_offset_left)
        profile.append(App.Vector(x, y, 0))

    # Add root arc to next tooth (closes the profile)
    root_arc_points = 5
    angle_end_left = angle_offset_left - theta_start if dedendum_radius > base_radius else angle_offset_left
    angle_start_next = angular_pitch + angle_offset_right - theta_start if dedendum_radius > base_radius else angular_pitch + angle_offset_right

    for i in range(root_arc_points):
        t = i / (root_arc_points - 1.0)
        angle = angle_end_left + t * (angle_start_next - angle_end_left)

        x = dedendum_radius * math.cos(angle)
        y = dedendum_radius * math.sin(angle)
        profile.append(App.Vector(x, y, 0))

    # Close the profile
    if profile[-1] != profile[0]:
        profile.append(profile[0])

    return profile


def generate_spur_gear_part(doc, parameters):
    """Generate complete spur gear 3D model.

    Creates a parametric spur gear with involute tooth profile.

    Args:
        doc: FreeCAD document
        parameters: Dictionary of gear parameters

    Raises:
        GearParameterError: If parameters are invalid
    """
    # Validate parameters first
    validate_spur_parameters(parameters)

    logger.info("Generating spur gear")

    # Get or create body
    body = doc.getObject('spur_gear')
    if body:
        body.removeObjectsFromDocument()
    else:
        body = doc.addObject('PartDesign::Body', 'spur_gear')

    # Extract parameters
    num_teeth = parameters["num_teeth"]
    height = parameters["height"]
    bore_type = parameters.get("bore_type", "none")

    # Create main gear body sketch with one tooth
    sketch = newSketch(body, 'ToothProfile')

    # Generate tooth profile
    tooth_profile = generate_tooth_profile(parameters)
    App.Console.PrintMessage(f"Generated tooth profile with {len(tooth_profile)} points\n")

    # Filter out duplicate consecutive points
    filtered_profile = [tooth_profile[0]]
    tolerance = 1e-6
    for i in range(1, len(tooth_profile)):
        prev_point = filtered_profile[-1]
        curr_point = tooth_profile[i]
        # Check if points are different (not within tolerance)
        distance = math.sqrt((curr_point.x - prev_point.x)**2 +
                           (curr_point.y - prev_point.y)**2)
        if distance > tolerance:
            filtered_profile.append(curr_point)

    App.Console.PrintMessage(f"Filtered profile has {len(filtered_profile)} points (removed {len(tooth_profile) - len(filtered_profile)} duplicates)\n")

    # Create smooth BSpline curve through the tooth profile points
    # Convert FreeCAD Vectors to lists for make_bspline
    profile_as_lists = [[p.x, p.y, p.z] for p in filtered_profile]

    # Create BSpline curve through all points
    bspline_curves = util.make_bspline([profile_as_lists])

    # Add the BSpline to the sketch
    for curve in bspline_curves:
        curve_shape = curve.toShape()
        geom_idx = sketch.addGeometry(curve_shape, False)
        # Block the curve to prevent it from moving
        sketch.addConstraint(Sketcher.Constraint('Block', geom_idx))

    App.Console.PrintMessage(f"Created smooth BSpline curve through {len(filtered_profile)} points\n")

    # Pad the tooth
    tooth_pad = newPad(body, sketch, height, 'Tooth')

    # Create polar pattern for all teeth
    polar = newPolar(body, tooth_pad, sketch, num_teeth, 'Teeth')
    polar.Originals = [tooth_pad]
    tooth_pad.Visibility = False
    polar.Visibility = True
    body.Tip = polar

    # Add bore if specified
    if bore_type != "none":
        generate_bore(body, parameters, height)

    # Recompute document
    doc.recompute()

    # Fit view if GUI available
    if GUI_AVAILABLE:
        try:
            Gui.SendMsgToActiveView("ViewFit")
        except Exception as e:
            logger.debug(f"Could not fit view: {e}")

    logger.info("Spur gear generation complete")


def generate_bore(body, parameters, height):
    """Generate center bore in gear.

    Args:
        body: FreeCAD Body object
        parameters: Gear parameters
        height: Depth of bore
    """
    bore_type = parameters["bore_type"]
    bore_diameter = parameters["bore_diameter"]

    if bore_type == "circular":
        generate_circular_bore(body, bore_diameter, height)
    elif bore_type == "square":
        corner_radius = parameters.get("square_corner_radius", 0.5)
        generate_square_bore(body, bore_diameter, corner_radius, height)
    elif bore_type == "hexagonal":
        corner_radius = parameters.get("hex_corner_radius", 0.5)
        generate_hex_bore(body, bore_diameter, corner_radius, height)
    elif bore_type == "keyway":
        keyway_width = parameters.get("keyway_width", 2.0)
        keyway_depth = parameters.get("keyway_depth", 1.0)
        generate_keyway_bore(body, bore_diameter, keyway_width, keyway_depth, height)


def generate_circular_bore(body, diameter, height):
    """Generate simple circular bore.

    Args:
        body: FreeCAD Body object
        diameter: Bore diameter
        height: Bore depth
    """
    sketch = newSketch(body, 'CircularBore')
    circle = sketch.addGeometry(Part.Circle(App.Vector(0, 0, 0), App.Vector(0, 0, 1), diameter / 2), False)
    sketch.addConstraint(Sketcher.Constraint('Coincident', circle, 3, -1, 1))
    sketch.addConstraint(Sketcher.Constraint('Diameter', circle, diameter))

    pocket = newPocket(body, sketch, height, 'Bore')
    body.Tip = pocket


def generate_square_bore(body, size, corner_radius, height):
    """Generate square bore with rounded corners.

    Args:
        body: FreeCAD Body object
        size: Square size (diameter of circumscribed circle)
        corner_radius: Radius of corners
        height: Bore depth
    """
    sketch = newSketch(body, 'SquareBore')
    half_size = size / (2 * math.sqrt(2))  # Half side length

    # Create square with rounded corners
    # This is simplified - a proper implementation would use fillets
    points = [
        App.Vector(half_size, half_size, 0),
        App.Vector(-half_size, half_size, 0),
        App.Vector(-half_size, -half_size, 0),
        App.Vector(half_size, -half_size, 0),
        App.Vector(half_size, half_size, 0)
    ]

    for i in range(len(points) - 1):
        sketch.addGeometry(Part.LineSegment(points[i], points[i + 1]), False)

    pocket = newPocket(body, sketch, height, 'Bore')
    body.Tip = pocket


def generate_hex_bore(body, diameter, corner_radius, height):
    """Generate hexagonal bore.

    Args:
        body: FreeCAD Body object
        diameter: Diameter of circumscribed circle
        corner_radius: Radius of corners
        height: Bore depth
    """
    sketch = newSketch(body, 'HexBore')
    radius = diameter / 2.0

    # Create hexagon points
    points = []
    for i in range(7):  # 7 points to close the hexagon
        angle = i * 60 * DEG_TO_RAD
        x = radius * math.cos(angle)
        y = radius * math.sin(angle)
        points.append(App.Vector(x, y, 0))

    # Add lines
    for i in range(6):
        sketch.addGeometry(Part.LineSegment(points[i], points[i + 1]), False)

    pocket = newPocket(body, sketch, height, 'Bore')
    body.Tip = pocket


def generate_keyway_bore(body, bore_diameter, keyway_width, keyway_depth, height):
    """Generate bore with DIN 6885 keyway.

    Args:
        body: FreeCAD Body object
        bore_diameter: Diameter of circular bore
        keyway_width: Width of keyway
        keyway_depth: Depth of keyway from bore surface
        height: Total depth
    """
    # First create circular bore
    generate_circular_bore(body, bore_diameter, height)

    # Add keyway as additional pocket
    sketch = newSketch(body, 'Keyway')

    # Keyway is a rectangle
    half_width = keyway_width / 2.0
    keyway_length = bore_diameter  # Extends across diameter

    points = [
        App.Vector(-half_width, 0, 0),
        App.Vector(half_width, 0, 0),
        App.Vector(half_width, keyway_length, 0),
        App.Vector(-half_width, keyway_length, 0),
        App.Vector(-half_width, 0, 0)
    ]

    for i in range(len(points) - 1):
        sketch.addGeometry(Part.LineSegment(points[i], points[i + 1]), False)

    pocket = newPocket(body, sketch, keyway_depth, 'Keyway')
    body.Tip = pocket


logger.info("gearMath module loaded successfully")
